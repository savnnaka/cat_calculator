{"ast":null,"code":"export default class Calculation {\n  constructor(expression) {\n    this.expression = expression;\n  }\n  /**\n   * validate expression string against regex expression\n   * (only based on characters: digits, *,+,/,-)\n   * @returns bool\n   */\n\n\n  validateInput_basic() {\n    const validExpression = /^[0-9.+\\-*/\\s]+$/; // Regular expression to match valid characters\n\n    console.log(\"expression is \" + this.expression);\n    return validExpression.test(this.expression);\n  }\n  /**\n   * basic evaluation of expression (only based on characters: digits, *,+,/,-)\n   * @returns {float} (result) // string\n   */\n\n\n  evaluate_basic() {\n    if (!this.validateInput_basic()) return undefined; // split into array\n\n    const splitExpression = this.expression.match(/(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-)/g);\n    const expressionString = splitExpression.join(\" \"); // Punkt vor Strich\n    // find all * or /, evaluate from left to right\n\n    let isError = false;\n\n    for (let index = 0; index < splitExpression.length; index++) {\n      const element = splitExpression[index];\n\n      if (element === \"*\" || element === \"/\") {\n        // take neighbours of operator\n        const a = parseFloat(splitExpression[index - 1]);\n        const b = parseFloat(splitExpression[index + 1]);\n\n        if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n          isError = true;\n          break;\n        }\n\n        let result = this.performOperation(element, a, b);\n        splitExpression.splice(index - 1, 3, result.toString());\n        index -= 2; // adjust index, as b is already processed\n      }\n    } // find all + or -, evaluate from left to right\n\n\n    for (let index = 0; index < splitExpression.length; index++) {\n      const element = splitExpression[index];\n\n      if (element === \"+\" || element === \"-\") {\n        const a = parseFloat(splitExpression[index - 1]);\n        const b = parseFloat(splitExpression[index + 1]);\n\n        if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n          isError = true;\n          break;\n        }\n\n        let result = this.performOperation(element, a, b);\n        splitExpression.splice(index - 1, 3, result.toString());\n        index -= 2; // adjust index, as b is already processed\n      }\n    }\n\n    if (isError) return undefined;\n    return expressionString + \" = \" + parseFloat(splitExpression[0]);\n  }\n  /**\n   * validate expression string against regex expression\n   * (only based on characters: digits, *,+,/,-,(,),^) \n   * @returns {bool}\n   */\n\n\n  validateInput_advanced() {\n    const validExpression = /^[0-9.+\\-*/\\(\\)^\\s]+$/; // Regular expression to match valid characters\n    // console.log(\"expression is \"+ this.expression);\n\n    return validExpression.test(this.expression);\n  }\n  /**\n   * converts infix into postfix notation\n   * @param {string} infix \n   * @returns {array} \n   */\n\n\n  infixToPostfix() {\n    // split string into array\n    const regex = /(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-|\\^|\\(|\\))/g;\n    const splitExpression = this.expression.match(regex);\n    if (!splitExpression) return undefined; // stack for operators\n\n    const stack = []; // queue for numbers\n\n    const queue = [];\n    const association = {\n      \"^\": \"right\",\n      \"*\": \"left\",\n      \"/\": \"left\",\n      \"+\": \"left\",\n      \"-\": \"left\"\n    };\n    var precedence = {\n      \"^\": 4,\n      \"*\": 3,\n      \"/\": 3,\n      \"+\": 2,\n      \"-\": 2\n    };\n    splitExpression.forEach(element => {\n      // push all digits on queue\n      if (element.match(/\\d+/)) {\n        queue.push(element);\n      } // elseif element is an operator (not a parenthesis)\n      else if (element.match(/[+*-/^]/)) {\n          // while there's at least one operator on the stack, compare to current operator\n          // to determine the order\n          let top = stack[stack.length - 1];\n\n          while (top && top.match(/[+*\\-/^]/) // no parenthesis\n          && (association[element] === \"left\" && precedence[element] === precedence[top] || precedence[element] < precedence[top])) {\n            queue.push(stack.pop());\n            top = stack[stack.length - 1];\n          }\n\n          stack.push(element);\n        } // push left parenthesis it onto the stack.\n        else if (element === \"(\") {\n            stack.push(element);\n          } // element is a right parenthesis:\n          else if (element === \")\") {\n              let top = stack[stack.length - 1]; // while the operator at the top of the operator stack is not a left parenthesis\n\n              while (top && top !== \"(\") {\n                // pop the operator from the operator stack into the output queue\n                queue.push(stack.pop());\n                top = stack[stack.length - 1];\n              } // assert the operator stack is not empty\n\n\n              if (!top) {\n                console.log(\"Parentheses mismatch\");\n                return undefined;\n              }\n\n              if (top === \"(\") {\n                stack.pop(); // Discard left parenthesis\n              }\n            }\n    }); // After the while loop, pop the remaining items from the operator stack into the output queue.\n\n    while (stack.length !== 0) {\n      let top = stack[stack.length - 1];\n\n      if (top === \"(\" || top === \")\") {\n        console.log(\"Parentheses mismatch\");\n        return undefined;\n      }\n\n      queue.push(stack.pop());\n    }\n\n    return queue;\n  }\n\n  /**\n   * \n   * @param operator \n   * @param {float} a \n   * @param {float} b \n   * @returns {float} result\n   */\n  performOperation(operator, a, b) {\n    switch (operator) {\n      case '+':\n        return a + b;\n\n      case '-':\n        return a - b;\n\n      case '*':\n        return a * b;\n\n      case '/':\n        return a / b;\n\n      case '^':\n        return Math.pow(a, b);\n\n      default:\n        throw new Error('Invalid operator: ' + operator);\n    }\n  }\n\n  evaluatePostfix(postfix) {\n    // return if postfix is undefined\n    if (!postfix) return undefined; // stack for the digits\n\n    const numbers = [];\n    postfix.forEach(element => {\n      if (!isNaN(parseFloat(element)) && isFinite(element)) {\n        numbers.push(parseFloat(element));\n      } else {\n        let b = numbers.pop();\n        let a = numbers.pop();\n        let result = this.performOperation(element, a, b);\n        numbers.push(result);\n      }\n    });\n    if (isNaN(numbers[0])) return undefined;\n    return numbers[0];\n  }\n  /**\n   * @param {string} expression \n   * @returns {string} parsedExpression \n   */\n\n\n  parseInput() {\n    // split string into array\n    const regex = /(\\d+(\\.\\d+)?|\\*|\\/|\\+|-|\\^|\\(|\\))/g;\n    const inputSplitted = this.expression.match(regex);\n    return inputSplitted.join(\" \");\n  }\n  /**\n   * calls the specified evaluation method\n   * @returns float (result of expression)\n   */\n\n\n  calculate() {\n    /**\n     * @TODO Add your implementation here\n     */\n    return this.evaluatePostfix(this.infixToPostfix());\n  }\n\n}","map":{"version":3,"sources":["/home/karin/Dokumente/Uni/SS23/React/IT Design/java-script-react-karin-haslauer/src/logic/calculation.js"],"names":["Calculation","constructor","expression","validateInput_basic","validExpression","console","log","test","evaluate_basic","undefined","splitExpression","match","expressionString","join","isError","index","length","element","a","parseFloat","b","isNaN","isFinite","result","performOperation","splice","toString","validateInput_advanced","infixToPostfix","regex","stack","queue","association","precedence","forEach","push","top","pop","operator","Math","pow","Error","evaluatePostfix","postfix","numbers","parseInput","inputSplitted","calculate"],"mappings":"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","sourcesContent":["export default class Calculation {\n    constructor(expression) {\n        this.expression = expression;\n    }\n\n    /**\n     * validate expression string against regex expression\n     * (only based on characters: digits, *,+,/,-)\n     * @returns bool\n     */\n    validateInput_basic() {\n        const validExpression = /^[0-9.+\\-*/\\s]+$/; // Regular expression to match valid characters\n        console.log(\"expression is \"+ this.expression);\n        return validExpression.test(this.expression);\n    }\n\n    /**\n     * basic evaluation of expression (only based on characters: digits, *,+,/,-)\n     * @returns {float} (result) // string\n     */\n    evaluate_basic() {\n        if(!this.validateInput_basic()) return undefined;\n\n        // split into array\n        const splitExpression = this.expression.match(/(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-)/g);\n        const expressionString = splitExpression.join(\" \")\n\n        // Punkt vor Strich\n        // find all * or /, evaluate from left to right\n        let isError = false;\n        for (let index = 0; index < splitExpression.length; index++) {\n            const element = splitExpression[index];\n        \n            if (element === \"*\" || element === \"/\") {\n                // take neighbours of operator\n                const a = parseFloat(splitExpression[index - 1]);\n                const b = parseFloat(splitExpression[index + 1]);\n            \n                if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n                    isError = true;\n                    break;\n                }\n            \n                let result = this.performOperation(element, a, b);\n            \n                splitExpression.splice(index - 1, 3, result.toString());\n                index -= 2; // adjust index, as b is already processed\n            }\n        }\n        \n        // find all + or -, evaluate from left to right\n        for (let index = 0; index < splitExpression.length; index++) {\n            const element = splitExpression[index];\n        \n            if (element === \"+\" || element === \"-\") {\n                const a = parseFloat(splitExpression[index - 1]);\n                const b = parseFloat(splitExpression[index + 1]);\n        \n                if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n                    isError = true;\n                    break;\n                }\n            \n                let result = this.performOperation(element, a, b);\n            \n                splitExpression.splice(index - 1, 3, result.toString());\n                index -= 2; // adjust index, as b is already processed\n            }\n      }\n    \n      if (isError) return undefined;\n      return expressionString + \" = \" + parseFloat(splitExpression[0]);\n    }\n\n    /**\n     * validate expression string against regex expression\n     * (only based on characters: digits, *,+,/,-,(,),^) \n     * @returns {bool}\n     */\n    validateInput_advanced() {\n        const validExpression = /^[0-9.+\\-*/\\(\\)^\\s]+$/; // Regular expression to match valid characters\n        // console.log(\"expression is \"+ this.expression);\n        return validExpression.test(this.expression);\n    }\n\n    /**\n     * converts infix into postfix notation\n     * @param {string} infix \n     * @returns {array} \n     */\n    infixToPostfix(){\n\n        // split string into array\n        const regex = /(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-|\\^|\\(|\\))/g;\n        const splitExpression = this.expression.match(regex);\n\n        if(!splitExpression) return undefined;\n\n        // stack for operators\n        const stack = [];\n        // queue for numbers\n        const queue = [];\n\n        const association = {\n            \"^\" : \"right\",\n            \"*\" : \"left\",\n            \"/\" : \"left\",\n            \"+\" : \"left\",\n            \"-\" : \"left\",\n        };\n\n        var precedence = {\n            \"^\" : 4,\n            \"*\" : 3,\n            \"/\" : 3,\n            \"+\" : 2,\n            \"-\" : 2,\n        };\n\n        splitExpression.forEach(element => {\n            // push all digits on queue\n            if(element.match(/\\d+/)){\n                queue.push(element);\n            }\n            // elseif element is an operator (not a parenthesis)\n            else if(element.match(/[+*-/^]/)){\n                // while there's at least one operator on the stack, compare to current operator\n                // to determine the order\n                let top = stack[stack.length - 1];\n                while(top \n                && top.match(/[+*\\-/^]/) // no parenthesis\n                && ((association[element] === \"left\" && precedence[element] === precedence[top])\n                || (precedence[element] < precedence[top]))){\n                    queue.push(stack.pop());\n                    top = stack[stack.length - 1];\n                }\n                stack.push(element);\n            }\n\n            // push left parenthesis it onto the stack.\n            else if(element === \"(\") {\n                stack.push(element);\n            }\n            // element is a right parenthesis:\n            else if(element === \")\") {\n                let top = stack[stack.length - 1];\n                // while the operator at the top of the operator stack is not a left parenthesis\n                while(top && top !== \"(\"){\n                    // pop the operator from the operator stack into the output queue\n                    queue.push(stack.pop());\n                    top = stack[stack.length - 1];\n                }\n                // assert the operator stack is not empty\n                if(!top){\n                    console.log(\"Parentheses mismatch\");\n                    return undefined;\n                }\n                if(top === \"(\"){\n                    stack.pop(); // Discard left parenthesis\n                }\n            }\n        });\n\n        // After the while loop, pop the remaining items from the operator stack into the output queue.\n        while(stack.length !== 0){\n            let top = stack[stack.length - 1];\n            if(top === \"(\" || top === \")\"){\n                console.log(\"Parentheses mismatch\");\n                return undefined;\n            }\n            queue.push(stack.pop());\n        }\n\n        return queue;\n    };\n\n    /**\n     * \n     * @param operator \n     * @param {float} a \n     * @param {float} b \n     * @returns {float} result\n     */\n    performOperation(operator, a, b) {\n        switch (operator) {\n        case '+':\n            return a + b;\n        case '-':\n            return a - b;\n        case '*':\n            return a * b;\n        case '/':\n            return a / b;\n        case '^':\n            return Math.pow(a, b);\n        default:\n            throw new Error('Invalid operator: ' + operator);\n        }\n    }\n\n    evaluatePostfix(postfix) {\n        // return if postfix is undefined\n        if(!postfix) return undefined;\n        // stack for the digits\n        const numbers = [];\n      \n        postfix.forEach(element => {\n            if (!isNaN(parseFloat(element)) && isFinite(element)) {\n              numbers.push(parseFloat(element));\n            } else {\n              let b = numbers.pop();\n              let a = numbers.pop();\n              let result = this.performOperation(element, a, b);\n              numbers.push(result);\n            }\n        });\n      \n        if(isNaN(numbers[0])) return undefined;\n        return numbers[0];\n    }\n\n    /**\n     * @param {string} expression \n     * @returns {string} parsedExpression \n     */\n    parseInput(){\n        // split string into array\n        const regex = /(\\d+(\\.\\d+)?|\\*|\\/|\\+|-|\\^|\\(|\\))/g;\n        const inputSplitted = this.expression.match(regex);\n        return inputSplitted.join(\" \");\n    }\n\n\n    /**\n     * calls the specified evaluation method\n     * @returns float (result of expression)\n     */\n    calculate() {\n        /**\n         * @TODO Add your implementation here\n         */\n        return this.evaluatePostfix(this.infixToPostfix());\n    }\n}\n"]},"metadata":{},"sourceType":"module"}