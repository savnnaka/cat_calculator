{"ast":null,"code":"export default class Calculation {\n  constructor(expression) {\n    this.expression = expression;\n  }\n\n  validateInput() {\n    // validate expression first (only based on characters)\n    const validExpression = /^[0-9.+\\-*/\\s]+$/; // Regular expression to match valid characters\n\n    console.log(\"expression is \" + this.expression);\n    return validExpression.test(this.expression);\n  }\n\n  evaluate() {\n    if (!this.validateInput()) return undefined; // split into array\n\n    const originalExpression = this.expression.match(/(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-)/g);\n    const splitExpression = originalExpression;\n    console.log(splitExpression); // Punkt vor Strich\n    // find all * or /, evaluate from left to right\n\n    let isError = false;\n\n    for (let index = 0; index < splitExpression.length; index++) {\n      const element = splitExpression[index];\n\n      if (element === \"*\" || element === \"/\") {\n        const a = parseFloat(splitExpression[index - 1]);\n        const b = parseFloat(splitExpression[index + 1]);\n\n        if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n          isError = true;\n          break;\n        }\n\n        let result = 0;\n\n        if (element === \"*\") {\n          result = a * b;\n        }\n\n        if (element === \"/\") {\n          result = a / b;\n        }\n\n        splitExpression.splice(index - 1, 3, result.toString());\n        index -= 2; // Adjust the index after modifying the array\n      }\n    } // find all + or -, evaluate from left to right\n\n\n    for (let index = 0; index < splitExpression.length; index++) {\n      const element = splitExpression[index];\n\n      if (element === \"+\" || element === \"-\") {\n        const a = parseFloat(splitExpression[index - 1]);\n        const b = parseFloat(splitExpression[index + 1]);\n\n        if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n          isError = true;\n          break;\n        }\n\n        let result = 0;\n\n        if (element === \"-\") {\n          result = a - b;\n        }\n\n        if (element === \"+\") {\n          result = a + b;\n        }\n\n        splitExpression.splice(index - 1, 3, result.toString());\n        index -= 2; // Adjust the index after modifying the array\n      }\n    }\n\n    if (isError) return undefined;\n    return originalExpression.join(\" \") + \" = \" + parseFloat(splitExpression[0]);\n  }\n\n  calculate() {\n    /**\n     * @TODO Add your implementaiton here\n     */\n    console.log(\"calculate is being called\");\n    return this.evaluate();\n  }\n\n}","map":{"version":3,"sources":["/home/karin/Dokumente/Uni/SS23/React/IT Design/java-script-react-karin-haslauer/src/logic/calculation.js"],"names":["Calculation","constructor","expression","validateInput","validExpression","console","log","test","evaluate","undefined","originalExpression","match","splitExpression","isError","index","length","element","a","parseFloat","b","isNaN","isFinite","result","splice","toString","join","calculate"],"mappings":"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","sourcesContent":["export default class Calculation {\n    constructor(expression) {\n        this.expression = expression;\n    }\n\n    validateInput() {\n        // validate expression first (only based on characters)\n        const validExpression = /^[0-9.+\\-*/\\s]+$/; // Regular expression to match valid characters\n        console.log(\"expression is \"+ this.expression);\n        return validExpression.test(this.expression);\n    }\n\n    evaluate() {\n        if(!this.validateInput()) return undefined;\n\n        // split into array\n        const originalExpression = this.expression.match(/(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-)/g);\n        const splitExpression = originalExpression; \n        console.log(splitExpression);\n\n        // Punkt vor Strich\n        // find all * or /, evaluate from left to right\n        let isError = false;\n        for (let index = 0; index < splitExpression.length; index++) {\n            const element = splitExpression[index];\n        \n            if (element === \"*\" || element === \"/\") {\n            const a = parseFloat(splitExpression[index - 1]);\n            const b = parseFloat(splitExpression[index + 1]);\n        \n            if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n                isError = true;\n                break;\n            }\n        \n            let result = 0;\n        \n            if (element === \"*\") {\n                result = a * b;\n            }\n        \n            if (element === \"/\") {\n                result = a / b;\n            }\n        \n            splitExpression.splice(index - 1, 3, result.toString());\n            index -= 2; // Adjust the index after modifying the array\n            }\n        }\n        \n        // find all + or -, evaluate from left to right\n        for (let index = 0; index < splitExpression.length; index++) {\n            const element = splitExpression[index];\n        \n            if (element === \"+\" || element === \"-\") {\n            const a = parseFloat(splitExpression[index - 1]);\n            const b = parseFloat(splitExpression[index + 1]);\n        \n            if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n                isError = true;\n                break;\n            }\n        \n            let result = 0;\n        \n            if (element === \"-\") {\n                result = a - b;\n            }\n        \n            if (element === \"+\") {\n                result = a + b;\n            }\n        \n            splitExpression.splice(index - 1, 3, result.toString());\n            index -= 2; // Adjust the index after modifying the array\n            }\n      }\n    \n      if (isError) return undefined;\n      return originalExpression.join(\" \") + \" = \" + parseFloat(splitExpression[0]);\n\n    }\n\n    calculate() {\n        /**\n         * @TODO Add your implementaiton here\n         */\n        console.log(\"calculate is being called\");\n        return this.evaluate();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}