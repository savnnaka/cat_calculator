{"ast":null,"code":"import _classCallCheck from\"/home/karin/Dokumente/Uni/SS23/React/IT Design/cat_calculator/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/karin/Dokumente/Uni/SS23/React/IT Design/cat_calculator/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";var Calculation=/*#__PURE__*/function(){function Calculation(expression){_classCallCheck(this,Calculation);this.expression=expression;}/**\n     * validate expression string against regex expression\n     * (only based on characters: digits, *,+,/,-)\n     * @returns bool\n     */_createClass(Calculation,[{key:\"validateInput_basic\",value:function validateInput_basic(){var validExpression=/^[0-9.+\\-*/\\s]+$/;// Regular expression to match valid characters\nconsole.log(\"expression is \"+this.expression);return validExpression.test(this.expression);}/**\n     * basic evaluation of expression (only based on characters: digits, *,+,/,-)\n     * @returns {float} (result) // string\n     */},{key:\"evaluate_basic\",value:function evaluate_basic(){if(!this.validateInput_basic())return undefined;// split into array\nvar splitExpression=this.expression.match(/(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-)/g);var expressionString=splitExpression.join(\" \");// Punkt vor Strich\n// find all * or /, evaluate from left to right\nvar isError=false;for(var index=0;index<splitExpression.length;index++){var element=splitExpression[index];if(element===\"*\"||element===\"/\"){// take neighbours of operator\nvar a=parseFloat(splitExpression[index-1]);var b=parseFloat(splitExpression[index+1]);if(isNaN(a)||isNaN(b)||!isFinite(a)||!isFinite(b)){isError=true;break;}var result=this.performOperation(element,a,b);splitExpression.splice(index-1,3,result.toString());index-=2;// adjust index, as b is already processed\n}}// find all + or -, evaluate from left to right\nfor(var _index=0;_index<splitExpression.length;_index++){var _element=splitExpression[_index];if(_element===\"+\"||_element===\"-\"){var _a=parseFloat(splitExpression[_index-1]);var _b=parseFloat(splitExpression[_index+1]);if(isNaN(_a)||isNaN(_b)||!isFinite(_a)||!isFinite(_b)){isError=true;break;}var _result=this.performOperation(_element,_a,_b);splitExpression.splice(_index-1,3,_result.toString());_index-=2;// adjust index, as b is already processed\n}}if(isError)return undefined;return expressionString+\" = \"+parseFloat(splitExpression[0]);}/**\n     * validate expression string against regex expression\n     * (only based on characters: digits, *,+,/,-,(,),^) \n     * @returns {bool}\n     */},{key:\"validateInput_advanced\",value:function validateInput_advanced(){var validExpression=/^[0-9.+\\-*/\\(\\)^\\s]+$/;// Regular expression to match valid characters\n// console.log(\"expression is \"+ this.expression);\nreturn validExpression.test(this.expression);}/**\n     * converts infix into postfix notation\n     * @param {string} infix \n     * @returns {array} \n     */},{key:\"infixToPostfix\",value:function infixToPostfix(){// split string into array\nvar regex=/(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-|\\^|\\(|\\))/g;var splitExpression=this.expression.match(regex);if(!splitExpression)return undefined;// stack for operators\nvar stack=[];// queue for numbers\nvar queue=[];var association={\"^\":\"right\",\"*\":\"left\",\"/\":\"left\",\"+\":\"left\",\"-\":\"left\"};var precedence={\"^\":4,\"*\":3,\"/\":3,\"+\":2,\"-\":2};splitExpression.forEach(function(element){// push all digits on queue\nif(element.match(/\\d+/)){queue.push(element);}// elseif element is an operator (not a parenthesis)\nelse if(element.match(/[\\+\\*\\-\\/^]/)){// while there's at least one operator on the stack, compare to current operator\n// to determine the order\nvar top=stack[stack.length-1];while(top&&top.match(/[\\+\\*\\-\\/^]/)// no parenthesis\n&&(association[element]===\"left\"&&precedence[element]===precedence[top]||precedence[element]<precedence[top])){queue.push(stack.pop());top=stack[stack.length-1];}stack.push(element);}// push left parenthesis it onto the stack.\nelse if(element===\"(\"){stack.push(element);}// element is a right parenthesis:\nelse if(element===\")\"){var _top=stack[stack.length-1];// while the operator at the top of the operator stack is not a left parenthesis\nwhile(_top&&_top!==\"(\"){// pop the operator from the operator stack into the output queue\nqueue.push(stack.pop());_top=stack[stack.length-1];}// assert the operator stack is not empty\nif(!_top){console.log(\"Parentheses mismatch\");return undefined;}if(_top===\"(\"){stack.pop();// Discard left parenthesis\n}}});// After the while loop, pop the remaining items from the operator stack into the output queue.\nwhile(stack.length!==0){var top=stack[stack.length-1];if(top===\"(\"||top===\")\"){console.log(\"Parentheses mismatch\");return undefined;}queue.push(stack.pop());}return queue;}},{key:\"performOperation\",value:/**\n     * \n     * @param operator \n     * @param {float} a \n     * @param {float} b \n     * @returns {float} result\n     */function performOperation(operator,a,b){switch(operator){case'+':return a+b;case'-':return a-b;case'*':return a*b;case'/':return a/b;case'^':return Math.pow(a,b);default:throw new Error('Invalid operator: '+operator);}}},{key:\"evaluatePostfix\",value:function evaluatePostfix(postfix){var _this=this;// return if postfix is undefined\nif(!postfix)return undefined;// stack for the digits\nvar numbers=[];postfix.forEach(function(element){if(!isNaN(parseFloat(element))&&isFinite(element)){numbers.push(parseFloat(element));}else{var b=numbers.pop();var a=numbers.pop();var result=_this.performOperation(element,a,b);numbers.push(result);}});if(isNaN(numbers[0]))return undefined;return numbers[0];}/**\n     * @param {string} expression \n     * @returns {string} parsedExpression \n     */},{key:\"parseInput\",value:function parseInput(){// split string into array\nvar regex=/(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-|\\^|\\(|\\))/g;var inputSplitted=this.expression.match(regex);return inputSplitted.join(\" \");}/**\n     * calls the specified evaluation method\n     * @returns float (result of expression)\n     */},{key:\"calculate\",value:function calculate(){/**\n         * @TODO Add your implementation here\n         */return this.evaluatePostfix(this.infixToPostfix());}}]);return Calculation;}();export{Calculation as default};","map":{"version":3,"sources":["/home/karin/Dokumente/Uni/SS23/React/IT Design/cat_calculator/src/logic/calculation.js"],"names":["Calculation","expression","validExpression","console","log","test","validateInput_basic","undefined","splitExpression","match","expressionString","join","isError","index","length","element","a","parseFloat","b","isNaN","isFinite","result","performOperation","splice","toString","regex","stack","queue","association","precedence","forEach","push","top","pop","operator","Math","pow","Error","postfix","numbers","inputSplitted","evaluatePostfix","infixToPostfix"],"mappings":"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","sourcesContent":["export default class Calculation {\n    constructor(expression) {\n        this.expression = expression;\n    }\n\n    /**\n     * validate expression string against regex expression\n     * (only based on characters: digits, *,+,/,-)\n     * @returns bool\n     */\n    validateInput_basic() {\n        const validExpression = /^[0-9.+\\-*/\\s]+$/; // Regular expression to match valid characters\n        console.log(\"expression is \"+ this.expression);\n        return validExpression.test(this.expression);\n    }\n\n    /**\n     * basic evaluation of expression (only based on characters: digits, *,+,/,-)\n     * @returns {float} (result) // string\n     */\n    evaluate_basic() {\n        if(!this.validateInput_basic()) return undefined;\n\n        // split into array\n        const splitExpression = this.expression.match(/(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-)/g);\n        const expressionString = splitExpression.join(\" \")\n\n        // Punkt vor Strich\n        // find all * or /, evaluate from left to right\n        let isError = false;\n        for (let index = 0; index < splitExpression.length; index++) {\n            const element = splitExpression[index];\n        \n            if (element === \"*\" || element === \"/\") {\n                // take neighbours of operator\n                const a = parseFloat(splitExpression[index - 1]);\n                const b = parseFloat(splitExpression[index + 1]);\n            \n                if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n                    isError = true;\n                    break;\n                }\n            \n                let result = this.performOperation(element, a, b);\n            \n                splitExpression.splice(index - 1, 3, result.toString());\n                index -= 2; // adjust index, as b is already processed\n            }\n        }\n        \n        // find all + or -, evaluate from left to right\n        for (let index = 0; index < splitExpression.length; index++) {\n            const element = splitExpression[index];\n        \n            if (element === \"+\" || element === \"-\") {\n                const a = parseFloat(splitExpression[index - 1]);\n                const b = parseFloat(splitExpression[index + 1]);\n        \n                if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n                    isError = true;\n                    break;\n                }\n            \n                let result = this.performOperation(element, a, b);\n            \n                splitExpression.splice(index - 1, 3, result.toString());\n                index -= 2; // adjust index, as b is already processed\n            }\n      }\n    \n      if (isError) return undefined;\n      return expressionString + \" = \" + parseFloat(splitExpression[0]);\n    }\n\n    /**\n     * validate expression string against regex expression\n     * (only based on characters: digits, *,+,/,-,(,),^) \n     * @returns {bool}\n     */\n    validateInput_advanced() {\n        const validExpression = /^[0-9.+\\-*/\\(\\)^\\s]+$/; // Regular expression to match valid characters\n        // console.log(\"expression is \"+ this.expression);\n        return validExpression.test(this.expression);\n    }\n\n    /**\n     * converts infix into postfix notation\n     * @param {string} infix \n     * @returns {array} \n     */\n    infixToPostfix(){\n\n        // split string into array\n        const regex = /(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-|\\^|\\(|\\))/g;\n        const splitExpression = this.expression.match(regex);\n\n        if(!splitExpression) return undefined;\n\n        // stack for operators\n        const stack = [];\n        // queue for numbers\n        const queue = [];\n\n        const association = {\n            \"^\" : \"right\",\n            \"*\" : \"left\",\n            \"/\" : \"left\",\n            \"+\" : \"left\",\n            \"-\" : \"left\",\n        };\n\n        var precedence = {\n            \"^\" : 4,\n            \"*\" : 3,\n            \"/\" : 3,\n            \"+\" : 2,\n            \"-\" : 2,\n        };\n\n        splitExpression.forEach(element => {\n            // push all digits on queue\n            if(element.match(/\\d+/)){\n                queue.push(element);\n            }\n            // elseif element is an operator (not a parenthesis)\n            else if(element.match(/[\\+\\*\\-\\/^]/)){\n                // while there's at least one operator on the stack, compare to current operator\n                // to determine the order\n                let top = stack[stack.length - 1];\n                while(top \n                && top.match(/[\\+\\*\\-\\/^]/) // no parenthesis\n                && ((association[element] === \"left\" && precedence[element] === precedence[top])\n                || (precedence[element] < precedence[top]))){\n                    queue.push(stack.pop());\n                    top = stack[stack.length - 1];\n                }\n                stack.push(element);\n            }\n\n            // push left parenthesis it onto the stack.\n            else if(element === \"(\") {\n                stack.push(element);\n            }\n            // element is a right parenthesis:\n            else if(element === \")\") {\n                let top = stack[stack.length - 1];\n                // while the operator at the top of the operator stack is not a left parenthesis\n                while(top && top !== \"(\"){\n                    // pop the operator from the operator stack into the output queue\n                    queue.push(stack.pop());\n                    top = stack[stack.length - 1];\n                }\n                // assert the operator stack is not empty\n                if(!top){\n                    console.log(\"Parentheses mismatch\");\n                    return undefined;\n                }\n                if(top === \"(\"){\n                    stack.pop(); // Discard left parenthesis\n                }\n            }\n        });\n\n        // After the while loop, pop the remaining items from the operator stack into the output queue.\n        while(stack.length !== 0){\n            let top = stack[stack.length - 1];\n            if(top === \"(\" || top === \")\"){\n                console.log(\"Parentheses mismatch\");\n                return undefined;\n            }\n            queue.push(stack.pop());\n        }\n\n        return queue;\n    };\n\n    /**\n     * \n     * @param operator \n     * @param {float} a \n     * @param {float} b \n     * @returns {float} result\n     */\n    performOperation(operator, a, b) {\n        switch (operator) {\n        case '+':\n            return a + b;\n        case '-':\n            return a - b;\n        case '*':\n            return a * b;\n        case '/':\n            return a / b;\n        case '^':\n            return Math.pow(a, b);\n        default:\n            throw new Error('Invalid operator: ' + operator);\n        }\n    }\n\n    evaluatePostfix(postfix) {\n        // return if postfix is undefined\n        if(!postfix) return undefined;\n        // stack for the digits\n        const numbers = [];\n      \n        postfix.forEach(element => {\n            if (!isNaN(parseFloat(element)) && isFinite(element)) {\n              numbers.push(parseFloat(element));\n            } else {\n              let b = numbers.pop();\n              let a = numbers.pop();\n              let result = this.performOperation(element, a, b);\n              numbers.push(result);\n            }\n        });\n      \n        if(isNaN(numbers[0])) return undefined;\n        return numbers[0];\n    }\n\n    /**\n     * @param {string} expression \n     * @returns {string} parsedExpression \n     */\n    parseInput(){\n        // split string into array\n        const regex = /(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-|\\^|\\(|\\))/g;\n        const inputSplitted = this.expression.match(regex);\n        return inputSplitted.join(\" \");\n    }\n\n\n    /**\n     * calls the specified evaluation method\n     * @returns float (result of expression)\n     */\n    calculate() {\n        /**\n         * @TODO Add your implementation here\n         */\n        return this.evaluatePostfix(this.infixToPostfix());\n    }\n}\n"]},"metadata":{},"sourceType":"module"}