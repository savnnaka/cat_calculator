{"ast":null,"code":"export default class Calculation {\n  constructor(expression) {\n    this.expression = expression;\n  }\n  /**\n   * validate expression string against regex expression\n   * (only based on characters: digits, *,+,/,-)\n   * @returns bool\n   */\n\n\n  validateInput_basic() {\n    const validExpression = /^[0-9.+\\-*/\\s]+$/; // Regular expression to match valid characters\n\n    console.log(\"expression is \" + this.expression);\n    return validExpression.test(this.expression);\n  }\n  /**\n   * basic evaluation of expression (only based on characters: digits, *,+,/,-)\n   * @returns float (result) // string\n   */\n\n\n  evaluate_basic() {\n    if (!this.validateInput_basic()) return undefined; // split into array\n\n    const splitExpression = this.expression.match(/(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-)/g);\n    console.log(splitExpression);\n    const expressionString = splitExpression.join(\" \");\n    console.log(\"expression String\" + expressionString); // Punkt vor Strich\n    // find all * or /, evaluate from left to right\n\n    let isError = false;\n\n    for (let index = 0; index < splitExpression.length; index++) {\n      const element = splitExpression[index];\n\n      if (element === \"*\" || element === \"/\") {\n        const a = parseFloat(splitExpression[index - 1]);\n        const b = parseFloat(splitExpression[index + 1]);\n\n        if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n          isError = true;\n          break;\n        }\n\n        let result = 0;\n\n        if (element === \"*\") {\n          result = a * b;\n        }\n\n        if (element === \"/\") {\n          result = a / b;\n        }\n\n        splitExpression.splice(index - 1, 3, result.toString());\n        index -= 2; // Adjust the index after modifying the array\n      }\n    } // find all + or -, evaluate from left to right\n\n\n    for (let index = 0; index < splitExpression.length; index++) {\n      const element = splitExpression[index];\n\n      if (element === \"+\" || element === \"-\") {\n        const a = parseFloat(splitExpression[index - 1]);\n        const b = parseFloat(splitExpression[index + 1]);\n\n        if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n          isError = true;\n          break;\n        }\n\n        let result = 0;\n\n        if (element === \"-\") {\n          result = a - b;\n        }\n\n        if (element === \"+\") {\n          result = a + b;\n        }\n\n        splitExpression.splice(index - 1, 3, result.toString());\n        index -= 2; // Adjust the index after modifying the array\n      }\n    }\n\n    if (isError) return undefined;\n    return expressionString + \" = \" + parseFloat(splitExpression[0]);\n  }\n  /**\n   * validate expression string against regex expression\n   * (only based on characters: digits, *,+,/,-,(,),^)\n   * @returns bool\n   */\n\n\n  validateInput_advanced() {\n    const validExpression = /^[0-9.+\\-*/\\(\\)^\\s]+$/; // Regular expression to match valid characters\n\n    console.log(\"expression is \" + this.expression);\n    return validExpression.test(this.expression);\n  }\n  /**\n   * split into array\n   */\n\n\n  expression2Array_advanced() {\n    return this.expression.match(/(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-\\(\\)\\^)/g);\n  }\n\n  peek(stack) {\n    return stack[stack.length - 1];\n  }\n  /**\n   * Evaluation based on the shunting yard algorithm\n   * @returns float (result of expression)\n   */\n\n\n  evaluate_shuntingYard() {\n    const splitExpression = this.expression2Array_advanced(); // stack for operators\n\n    const stack = []; // queue for numbers\n\n    const queue = [];\n    const association = {\n      \"^\": \"right\",\n      \"*\": \"left\",\n      \"/\": \"left\",\n      \"+\": \"left\",\n      \"-\": \"left\"\n    };\n    var precedence = {\n      \"^\": 4,\n      \"*\": 3,\n      \"/\": 3,\n      \"+\": 2,\n      \"-\": 2\n    };\n    splitExpression.forEach(element => {\n      // push all digits on queue\n      if (element.match(/\\d+/)) {\n        queue.push(element);\n      } // elseif token is an operator (not a parenthesis)\n      else if (element.match(/[\\+\\*\\-\\/^]/)) {\n          // while there's at least one operator on the stack, compare to current operator\n          // to determine the order\n          if (stack[stack.length - 1]) {\n            let top = stack[stack.length - 1];\n\n            while (top && top.match(/[\\+\\*\\-\\/^]/) && (association[element] === \"left\" && precedence[element] == precedence[top] || association[element] === \"right\" && precedence[element] < precedence[top])) {\n              queue.push(stack.pop());\n              top = stack[stack.length - 1];\n            }\n          }\n\n          stack.push(element);\n        } // If the token is a function argument separator \n        else if (element === \",\") {\n            // Until the token at the top of the stack is a left parenthesis\n            // pop operators off the stack onto the output queue.\n            while (stack[stack.length - 1] != \"(\") {\n              queue.push(stack.pop());\n            }\n          } //If the token is a left parenthesis (i.e. \"(\"), then push it onto the stack.\n          else if (element === \"(\") {\n              stack.push(element);\n            } //If the token is a right parenthesis (i.e. \")\"):\n            else if (element === \")\") {\n                //Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.\n                while (stack[stack.length - 1] != \"(\") {\n                  queue.push(stack.pop());\n                } //Pop the left parenthesis from the stack, but not onto the output queue.\n\n\n                stack.pop(); //If the token at the top of the stack is a function token, pop it onto the output queue.\n\n                if (stack[stack.length - 1].match(/(sin|cos|tan)/)) {\n                  queue.push(stack.pop());\n                }\n              }\n    });\n    return queue.concat(stack.reverse()).join(\" \");\n    ;\n  }\n\n  /**\n   * calls the specified eelementaluation method\n   * @returns float (result of expression)\n   */\n  calculate() {\n    /**\n     * @TODO Add your implementaiton here\n     */\n    console.log(\"calculate is being called\");\n    return this.evaluate_shuntingYard();\n  }\n\n}","map":{"version":3,"sources":["/home/karin/Dokumente/Uni/SS23/React/IT Design/java-script-react-karin-haslauer/src/logic/calculation.js"],"names":["Calculation","constructor","expression","validateInput_basic","validExpression","console","log","test","evaluate_basic","undefined","splitExpression","match","expressionString","join","isError","index","length","element","a","parseFloat","b","isNaN","isFinite","result","splice","toString","validateInput_advanced","expression2Array_advanced","peek","stack","evaluate_shuntingYard","queue","association","precedence","forEach","push","top","pop","concat","reverse","calculate"],"mappings":"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","sourcesContent":["export default class Calculation {\n    constructor(expression) {\n        this.expression = expression;\n    }\n\n    /**\n     * validate expression string against regex expression\n     * (only based on characters: digits, *,+,/,-)\n     * @returns bool\n     */\n    validateInput_basic() {\n        const validExpression = /^[0-9.+\\-*/\\s]+$/; // Regular expression to match valid characters\n        console.log(\"expression is \"+ this.expression);\n        return validExpression.test(this.expression);\n    }\n\n    /**\n     * basic evaluation of expression (only based on characters: digits, *,+,/,-)\n     * @returns float (result) // string\n     */\n    evaluate_basic() {\n        if(!this.validateInput_basic()) return undefined;\n\n        // split into array\n        const splitExpression = this.expression.match(/(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-)/g);\n        console.log(splitExpression)\n        const expressionString = splitExpression.join(\" \")\n        console.log(\"expression String\" + expressionString);\n\n        // Punkt vor Strich\n        // find all * or /, evaluate from left to right\n        let isError = false;\n        for (let index = 0; index < splitExpression.length; index++) {\n            const element = splitExpression[index];\n        \n            if (element === \"*\" || element === \"/\") {\n            const a = parseFloat(splitExpression[index - 1]);\n            const b = parseFloat(splitExpression[index + 1]);\n        \n            if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n                isError = true;\n                break;\n            }\n        \n            let result = 0;\n        \n            if (element === \"*\") {\n                result = a * b;\n            }\n        \n            if (element === \"/\") {\n                result = a / b;\n            }\n        \n            splitExpression.splice(index - 1, 3, result.toString());\n            index -= 2; // Adjust the index after modifying the array\n            }\n        }\n        \n        // find all + or -, evaluate from left to right\n        for (let index = 0; index < splitExpression.length; index++) {\n            const element = splitExpression[index];\n        \n            if (element === \"+\" || element === \"-\") {\n            const a = parseFloat(splitExpression[index - 1]);\n            const b = parseFloat(splitExpression[index + 1]);\n        \n            if (isNaN(a) || isNaN(b) || !isFinite(a) || !isFinite(b)) {\n                isError = true;\n                break;\n            }\n        \n            let result = 0;\n        \n            if (element === \"-\") {\n                result = a - b;\n            }\n        \n            if (element === \"+\") {\n                result = a + b;\n            }\n        \n            splitExpression.splice(index - 1, 3, result.toString());\n            index -= 2; // Adjust the index after modifying the array\n            }\n      }\n    \n      if (isError) return undefined;\n      return expressionString + \" = \" + parseFloat(splitExpression[0]);\n\n    }\n\n    /**\n     * validate expression string against regex expression\n     * (only based on characters: digits, *,+,/,-,(,),^)\n     * @returns bool\n     */\n    validateInput_advanced() {\n        const validExpression = /^[0-9.+\\-*/\\(\\)^\\s]+$/; // Regular expression to match valid characters\n        console.log(\"expression is \"+ this.expression);\n        return validExpression.test(this.expression);\n    }\n\n    /**\n     * split into array\n     */\n    expression2Array_advanced() {\n        return this.expression.match(/(\\d+(\\.\\d+)?|\\*|\\/|\\+|\\-\\(\\)\\^)/g);\n    }\n\n    peek(stack) {\n        return stack[stack.length - 1];\n    }\n\n    /**\n     * Evaluation based on the shunting yard algorithm\n     * @returns float (result of expression)\n     */\n    evaluate_shuntingYard(){\n\n        const splitExpression = this.expression2Array_advanced();\n\n        // stack for operators\n        const stack = [];\n        // queue for numbers\n        const queue = [];\n\n        const association = {\n            \"^\" : \"right\",\n            \"*\" : \"left\",\n            \"/\" : \"left\",\n            \"+\" : \"left\",\n            \"-\" : \"left\",\n        };\n\n        var precedence = {\n            \"^\" : 4,\n            \"*\" : 3,\n            \"/\" : 3,\n            \"+\" : 2,\n            \"-\" : 2,\n        };\n\n        splitExpression.forEach(element => {\n            // push all digits on queue\n            if(element.match(/\\d+/)){\n                queue.push(element);\n            }\n            // elseif token is an operator (not a parenthesis)\n            else if(element.match(/[\\+\\*\\-\\/^]/)){\n                // while there's at least one operator on the stack, compare to current operator\n                // to determine the order\n                if(stack[stack.length - 1]) {\n                    let top = stack[stack.length - 1];\n                    while(top \n                    && top.match(/[\\+\\*\\-\\/^]/) \n                    && ((association[element] === \"left\" && precedence[element] == precedence[top])\n                    || (association[element] === \"right\" && precedence[element] < precedence[top]))){\n                        queue.push(stack.pop());\n                        top = stack[stack.length - 1];\n                    }\n                }\n                stack.push(element);\n            }\n\n            // If the token is a function argument separator \n            else if(element===\",\") {\n                // Until the token at the top of the stack is a left parenthesis\n                // pop operators off the stack onto the output queue.\n                while(stack[stack.length - 1] != \"(\") {\n                    queue.push(stack.pop());\n                }\n            } \n            //If the token is a left parenthesis (i.e. \"(\"), then push it onto the stack.\n            else if(element===\"(\") {\n                stack.push(element);\n            }\n            //If the token is a right parenthesis (i.e. \")\"):\n            else if(element===\")\") {\n                //Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.\n                while(stack[stack.length - 1] != \"(\") {\n                    queue.push(stack.pop());\n                }\n\n                //Pop the left parenthesis from the stack, but not onto the output queue.\n                stack.pop();\n\n                //If the token at the top of the stack is a function token, pop it onto the output queue.\n                if(stack[stack.length - 1].match(/(sin|cos|tan)/)) {\n                    queue.push(stack.pop());\n                }\n            }\n        });\n\n        return queue.concat(stack.reverse()).join(\" \");;\n    };\n\n    /**\n     * calls the specified eelementaluation method\n     * @returns float (result of expression)\n     */\n    calculate() {\n        /**\n         * @TODO Add your implementaiton here\n         */\n        console.log(\"calculate is being called\");\n        return this.evaluate_shuntingYard();\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}